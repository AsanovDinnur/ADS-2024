# -*- coding: utf-8 -*-
"""ADS report 2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-J6y9bkhNbgtbnHRkl8FL4FPk2zz9UO9

#Trees
"""

class Node:
    def __init__(self, key):
        self.left = None
        self.right = None
        self.val = key

def insert(root, key):
    if root is None:
        return Node(key)
    else:
        if key < root.val:
            root.left = insert(root.left, key)
        else:
            root.right = insert(root.right, key)
    return root

def inorder(root):
    if root:
        inorder(root.left)
        print(root.val)
        inorder(root.right)

# Example usage
root = Node(10)
root = insert(root, 20)
root = insert(root, 5)
root = insert(root, 15)
root = insert(root, 30)

print("In-order traversal of the binary tree:")
inorder(root)

"""######To know the size of a tree"""

def size(node):
    if node is None:
        return 0
    else:
        return 1 + size(node.left) + size(node.right)

"""#Binary Search Trees"""

class Node:
    def __init__(self, key):
        self.left = None
        self.right = None
        self.val = key

def insert(root, key):
    if root is None:
        return Node(key)
    if key < root.val:
        root.left = insert(root.left, key)
    else:
        root.right = insert(root.right, key)
    return root

# Example usage
root = None
keys = [20, 10, 30, 5, 15, 25, 35]
for key in keys:
    root = insert(root, key)

"""######Searching a Binary Search Tree"""

def search(root, key):
    if root is None or root.val == key:
        return root
    if key < root.val:
        return search(root.left, key)
    return search(root.right, key)

# Example usage
result = search(root, 15)
if result:
    print("Key found:", result.val)
else:
    print("Key not found")

"""#Priority Queues and Heap Trees

######Inserting a New Heap Tree Node
"""

def insert(heap, key):
    heap.append(key)  # Add the new key at the end
    i = len(heap) - 1
    while i > 0 and heap[(i - 1) // 2] < heap[i]:
        # Swap with the parent if the heap property is violated
        heap[(i - 1) // 2], heap[i] = heap[i], heap[(i - 1) // 2]
        i = (i - 1) // 2

# Example usage
heap = []
keys = [20, 10, 30, 5, 15, 25, 35]
for key in keys:
    insert(heap, key)
print(heap)  # Output: [35, 20, 30, 5, 15, 25, 10]

"""######Deleting a Heap Tree Node"""

def delete_root(heap):
    if len(heap) == 0:
        return None
    if len(heap) == 1:
        return heap.pop()

    root = heap[0]
    heap[0] = heap.pop()  # Replace root with the last element
    i = 0
    while (2 * i + 1) < len(heap):
        largest = i
        left = 2 * i + 1
        right = 2 * i + 2
        if left < len(heap) and heap[left] > heap[largest]:
            largest = left
        if right < len(heap) and heap[right] > heap[largest]:
            largest = right
        if largest == i:
            break
        heap[i], heap[largest] = heap[largest], heap[i]
        i = largest
    return root

# Example usage
deleted_root = delete_root(heap)
print(deleted_root)  # Output: 35
print(heap)  # Output: [30, 20, 25, 5, 15, 10]

"""######Building a New Heap Tree from Scratch"""

def heapify(heap, n, i):
    largest = i
    left = 2 * i + 1
    right = 2 * i + 2

    if left < n and heap[left] > heap[largest]:
        largest = left
    if right < n and heap[right] > heap[largest]:
        largest = right
    if largest != i:
        heap[i], heap[largest] = heap[largest], heap[i]
        heapify(heap, n, largest)

def build_heap(arr):
    n = len(arr)
    for i in range(n // 2 - 1, -1, -1):
        heapify(arr, n, i)

# Example usage
arr = [20, 10, 30, 5, 15, 25, 35]
build_heap(arr)
print(arr)  # Output: [35, 20, 30, 5, 15, 25, 10]

"""#The Problem of Sorting

Common Sorting Strategies
Several sorting algorithms are commonly used, each with different performance characteristics and use cases. Here are some of the most well-known sorting strategies:

Bubble Sort

Insertion Sort

Selection Sort

Merge Sort

Quick Sort

Heap Sort

Radix Sort

Counting Sort

######Bubble Sort
"""

def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        swapped = False
        for j in range(0, n-i-1):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
                swapped = True
        if not swapped:
            break

# Example usage
arr = [64, 34, 25, 12, 22, 11, 90]
bubble_sort(arr)
print("Sorted array:", arr)

"""######Insertion Sort

"""

def insertion_sort(arr):
    for i in range(1, len(arr)):
        key = arr[i]
        j = i - 1
        while j >= 0 and key < arr[j]:
            arr[j + 1] = arr[j]
            j -= 1
        arr[j + 1] = key

# Example usage
arr = [12, 11, 13, 5, 6]
insertion_sort(arr)
print("Sorted array:", arr)

"""######Selection Sort"""

def selection_sort(arr):
    for i in range(len(arr)):
        min_idx = i
        for j in range(i+1, len(arr)):
            if arr[j] < arr[min_idx]:
                min_idx = j
        arr[i], arr[min_idx] = arr[min_idx], arr[i]

# Example usage
arr = [64, 25, 12, 22, 11]
selection_sort(arr)
print("Sorted array:", arr)